/*
 * motor_encoder.c
 *
 *  Created on: Dec 14, 2023
 *      Author: miqix
 */
#include "Motors/motor_encoder.h"


void MotorEnc_Init(MotorEncoder_t *encoder, TIM_HandleTypeDef *htim)
{
	encoder->htimEnc = htim;
	HAL_TIM_Encoder_Start(htim, TIM_CHANNEL_ALL);
}

void MotorEnc_Uptade(MotorEncoder_t *encoder)
{
	uint32_t NewCounter = encoder->htimEnc->Instance->CNT;
	int16_t TempPosition = encoder->Position;

	if(NewCounter == encoder->LastCounter)
	{
		encoder->Velocity = 0;
	}
	else if(NewCounter > encoder->LastCounter)
	{
		if(__HAL_TIM_IS_TIM_COUNTING_DOWN(encoder->htimEnc))
		{
			encoder->Velocity = - ( encoder->LastCounter + (encoder->htimEnc->Instance->ARR - NewCounter) );
		}
		else
		{
			encoder->Velocity = NewCounter - encoder->LastCounter;
		}
	}
	else if(NewCounter < encoder->LastCounter)
	{
		if(__HAL_TIM_IS_TIM_COUNTING_DOWN(encoder->htimEnc))
		{
			encoder->Velocity = NewCounter - encoder->LastCounter;
		}
		else
		{
			encoder->Velocity = NewCounter + (encoder->htimEnc->Instance->ARR + encoder->LastCounter);
		}
	}

	encoder->LastCounter = NewCounter;

	TempPosition = encoder->Position + NewCounter;

	if(TempPosition >= 0 && encoder->Velocity != 0)
	{
		encoder->Position = (encoder->Position + NewCounter) % PULSES_PER_ROTATION;
	}
	else
	{
		encoder->Position = PULSES_PER_ROTATION + TempPosition;
	}

	encoder->RPM = (encoder->Velocity * 6000) / 350;

}
